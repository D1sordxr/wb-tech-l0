// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: orders.sql

package gen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createDelivery = `-- name: CreateDelivery :exec
INSERT INTO deliveries (
    order_uid,
    del_name,
    phone,
    zip,
    city,
    address,
    region,
    email
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8
)
`

type CreateDeliveryParams struct {
	OrderUid string      `json:"order_uid"`
	DelName  string      `json:"del_name"`
	Phone    string      `json:"phone"`
	Zip      pgtype.Text `json:"zip"`
	City     pgtype.Text `json:"city"`
	Address  pgtype.Text `json:"address"`
	Region   pgtype.Text `json:"region"`
	Email    pgtype.Text `json:"email"`
}

func (q *Queries) CreateDelivery(ctx context.Context, arg CreateDeliveryParams) error {
	_, err := q.db.Exec(ctx, createDelivery,
		arg.OrderUid,
		arg.DelName,
		arg.Phone,
		arg.Zip,
		arg.City,
		arg.Address,
		arg.Region,
		arg.Email,
	)
	return err
}

const createItem = `-- name: CreateItem :exec
INSERT INTO items (
    id,
    order_uid,
    chrt_id,
    track_number,
    price,
    rid,
    item_name,
    sale,
    item_size,
    total_price,
    nm_id,
    brand,
    status
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11,
    $12,
    $13
)
`

type CreateItemParams struct {
	ID          int32       `json:"id"`
	OrderUid    string      `json:"order_uid"`
	ChrtID      pgtype.Int8 `json:"chrt_id"`
	TrackNumber pgtype.Text `json:"track_number"`
	Price       pgtype.Int4 `json:"price"`
	Rid         pgtype.Text `json:"rid"`
	ItemName    pgtype.Text `json:"item_name"`
	Sale        pgtype.Int4 `json:"sale"`
	ItemSize    pgtype.Text `json:"item_size"`
	TotalPrice  pgtype.Int4 `json:"total_price"`
	NmID        pgtype.Int8 `json:"nm_id"`
	Brand       pgtype.Text `json:"brand"`
	Status      pgtype.Int4 `json:"status"`
}

func (q *Queries) CreateItem(ctx context.Context, arg CreateItemParams) error {
	_, err := q.db.Exec(ctx, createItem,
		arg.ID,
		arg.OrderUid,
		arg.ChrtID,
		arg.TrackNumber,
		arg.Price,
		arg.Rid,
		arg.ItemName,
		arg.Sale,
		arg.ItemSize,
		arg.TotalPrice,
		arg.NmID,
		arg.Brand,
		arg.Status,
	)
	return err
}

const createOrder = `-- name: CreateOrder :exec
INSERT INTO orders (
    order_uid,
    track_number,
    entry,
    locale,
    internal_signature,
    customer_id,
    delivery_service,
    shardkey,
    sm_id,
    date_created,
    oof_shard
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
)
`

type CreateOrderParams struct {
	OrderUid          string           `json:"order_uid"`
	TrackNumber       string           `json:"track_number"`
	Entry             string           `json:"entry"`
	Locale            string           `json:"locale"`
	InternalSignature pgtype.Text      `json:"internal_signature"`
	CustomerID        string           `json:"customer_id"`
	DeliveryService   pgtype.Text      `json:"delivery_service"`
	Shardkey          pgtype.Text      `json:"shardkey"`
	SmID              int32            `json:"sm_id"`
	DateCreated       pgtype.Timestamp `json:"date_created"`
	OofShard          pgtype.Text      `json:"oof_shard"`
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) error {
	_, err := q.db.Exec(ctx, createOrder,
		arg.OrderUid,
		arg.TrackNumber,
		arg.Entry,
		arg.Locale,
		arg.InternalSignature,
		arg.CustomerID,
		arg.DeliveryService,
		arg.Shardkey,
		arg.SmID,
		arg.DateCreated,
		arg.OofShard,
	)
	return err
}

const createPayment = `-- name: CreatePayment :exec
INSERT INTO payments (
    order_uid,
    transaction_id,
    request_id,
    currency,
    provider,
    amount,
    payment_dt,
    bank,
    delivery_cost,
    goods_total,
    custom_fee
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7,
    $8,
    $9,
    $10,
    $11
)
`

type CreatePaymentParams struct {
	OrderUid      string      `json:"order_uid"`
	TransactionID string      `json:"transaction_id"`
	RequestID     pgtype.Text `json:"request_id"`
	Currency      pgtype.Text `json:"currency"`
	Provider      pgtype.Text `json:"provider"`
	Amount        pgtype.Int4 `json:"amount"`
	PaymentDt     pgtype.Int8 `json:"payment_dt"`
	Bank          pgtype.Text `json:"bank"`
	DeliveryCost  pgtype.Int4 `json:"delivery_cost"`
	GoodsTotal    pgtype.Int4 `json:"goods_total"`
	CustomFee     pgtype.Int4 `json:"custom_fee"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) error {
	_, err := q.db.Exec(ctx, createPayment,
		arg.OrderUid,
		arg.TransactionID,
		arg.RequestID,
		arg.Currency,
		arg.Provider,
		arg.Amount,
		arg.PaymentDt,
		arg.Bank,
		arg.DeliveryCost,
		arg.GoodsTotal,
		arg.CustomFee,
	)
	return err
}

const getAllOrders = `-- name: GetAllOrders :many
SELECT order_uid, track_number, entry, locale, internal_signature, customer_id, delivery_service, shardkey, sm_id, date_created, oof_shard FROM orders
`

func (q *Queries) GetAllOrders(ctx context.Context) ([]Order, error) {
	rows, err := q.db.Query(ctx, getAllOrders)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.OrderUid,
			&i.TrackNumber,
			&i.Entry,
			&i.Locale,
			&i.InternalSignature,
			&i.CustomerID,
			&i.DeliveryService,
			&i.Shardkey,
			&i.SmID,
			&i.DateCreated,
			&i.OofShard,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrder = `-- name: GetOrder :one
SELECT order_uid, track_number, entry, locale, internal_signature, customer_id, delivery_service, shardkey, sm_id, date_created, oof_shard FROM orders
WHERE order_uid = $1
LIMIT 1
`

func (q *Queries) GetOrder(ctx context.Context, orderUid string) (Order, error) {
	row := q.db.QueryRow(ctx, getOrder, orderUid)
	var i Order
	err := row.Scan(
		&i.OrderUid,
		&i.TrackNumber,
		&i.Entry,
		&i.Locale,
		&i.InternalSignature,
		&i.CustomerID,
		&i.DeliveryService,
		&i.Shardkey,
		&i.SmID,
		&i.DateCreated,
		&i.OofShard,
	)
	return i, err
}
